SCRIPTS
1. Script to find all Malicious Strings and which functions they belong to
from ghidra.program.util import DefinedDataIterator 
from ghidra.app.util import XReferenceUtil 
 
def getAddress(offset): 
    return currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(offset) 
 
string_and_funcdata=[] 
functionManager = currentProgram.getFunctionManager() 
for string in DefinedDataIterator.definedStrings(currentProgram): 
  for ref in XReferenceUtil.getXRefList(string): 
 
    addr=getAddress(hex(int('0x'+str(ref),16))) 
 
    name_of_function=functionManager.getFunctionContaining(addr) 
    temp_list=[] 
    temp_list.extend([str(string),str(ref),str(name_of_function)]) 
 
    string_and_funcdata.append(temp_list) 
 
func_data={} 
 
for li in string_and_funcdata: 
   if li[2] in func_data.keys():     
       temp_list=[] 
       temp_list.extend([li[0],li[1]])   
       func_data[li[2]].append(temp_list) 
  
   if  li[2]!='None' and not(li[2] in func_data.keys()) : 
       func_data[li[2]]=[] 
       temp_list=[] 
       temp_list.append([li[0],li[1]]) 
       func_data[li[2]].extend(temp_list) 
    
print(func_data)

 
2.  Vulnerable Functions
import ghidra.app.script.GhidraScript;
import ghidra.program.model.lang.protorules.*;
import ghidra.program.model.mem.*;
import ghidra.program.model.lang.*;
import ghidra.program.model.pcode.*;
import ghidra.program.model.data.*;
import ghidra.program.model.data.ISF.*;
import ghidra.program.model.util.*;
import ghidra.program.model.reloc.*;
import ghidra.program.model.data.*;
import ghidra.program.model.block.*;
import ghidra.program.model.symbol.*;
import ghidra.program.model.scalar.*;
import ghidra.program.model.listing.*;
import ghidra.program.model.address.*;
public class j extends GhidraScript {
    public void run() throws Exception {
        println("Analyzing functions and symbols...");
        // Get all functions in the program
        FunctionIterator iter = currentProgram.getListing().getFunctions(true);
        while (iter.hasNext()) {
            Function function = iter.next();
            // Check criteria for identifying important functions
            if (isImportantFunction(function)) {
                println("Potential Important Function: " + function.getName());
                // Get the corresponding symbol for the function
                Symbol symbol = getSymbolForFunction(function);
                if (symbol != null) {
                    println("Symbol: " + symbol.getName());
                } else {
                    println("Symbol not found for function: " + function.getName());
                }
            }
        }
        println("Analysis complete.");
    }
    private boolean isImportantFunction(Function function) {
        // Criteria for identifying important functions
        // Example criteria: functions with more than 50 instructions
        // You can modify this criteria based on your specific requirements
        return countInstructions(function) > 50;
    }
    private int countInstructions(Function function) {
        int count = 0;
        InstructionIterator instructions = getInstructions(function);
        while (instructions.hasNext()) {
            instructions.next();
            count++;
        }
        return count;
    }
}
3.  Call Function Display


#description: Print all CALLs within a function.
#@author: Analyst
#@category _NEW_
fn = getFunctionAt(currentAddress)
i = getInstructionAt(currentAddress)
while getFunctionContaining(i.getAddress()) == fn:
    nem = i.getMnemonicString()
    if nem == "CALL":
        target_address = i.getOpObjects(0)[0]
        addr = currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(target_address.getOffset())
        print(nem + " " + str(getSymbolAt(addr)))
    i = i.getNext()

4. Preview function

# Names unindentified functions with a nomenclature that provides a preview of included capabilities within the function
#@author https://AGDCServices.com
#@category AGDCservices
#@keybinding
#@menupath
#@toolbar

'''
This script will name all unidentified functions with a nomenclature
that provides a preview of important capabilities included within the
function and all child functions.

The script includes a list of hardcoded important API calls. The
script will locate all calls contained in the unidentifed function
and it's children functions. For any of the calls which match
the hardcoded API call list, a shorthand name will be applied to
indicate which category of important call is contained within the function.

The naming nomenclature is based on capability and does not identify
specific APIs. By keeping the syntax short and just for capability,
you can get a preview of all the important capabilities within a function
without having the name get enormous.

The naming convention is as follows:
- all funtions automatically named will start with a f_p__
- a function will only be renamed if it starts with either the
  Ghidra default function name, or this scripts default function name.
  If any other name is found, it is expected the function was either 
  manually named or identified by a library signature, and it is
  assumed those names are more accurate than the automated preview name.
- each category will be seperated by a double underscore
- within each catagory, a specific capability is identified by a
  single "preview" letter.
- if the preview letter is uppercase, it means the capability
  was found in the current function. If the preview letter is
  lowercase, it means the capability was found somewhere in a
  child function.
- the last entry of the preview name will be the function address
  This is because Ghidra allows duplicate names, but when a name is
  selected, all copies are highlighted based only on the name.
  Because you often get duplicates of the preview name, adding the 
  functions address to the end will make each name unique so you can
  easily differentiate functions with the same base preview name.

One exception to the naming convention are functions which are the
start of a thread. These functions will only have the category
TS applied and will not contain any capability preview.
Because the thread starts are almost like mini-programs, this 
identifer is used just to identify the starting functions so you 
can manually review them to determine the general capabilities    
    
The preview letters are all single characters that are typically
the first letter of the capability. The categories and preview
letters used are below. To see the specific API calls that
correspond to each capability, see the list at the top of the
function, Build_New_Func_Name()


TS = thread start (no further capability preview will be applied)

netw = networking functionality
  b = build
  c = connect
  l = listen
  s = send
  r = receive
  t = terminate
  m = modify

reg = registry functionality
  h = handle
  r = read
  w = write
  d = delete

file = file processing functionality
  h = handle
  r = read
  w = write
  d = delete
  c = copy
  m = move
  e = enumerate

proc = process manipulation functionality
  h = handle
  e = enumerate
  c = create
  t = terminate
  r = read process memory
  w = write process memory

serv = service manipulation functionality
  h = handle
  c = create
  d = delete
  s = start
  r = read
  w = write

thread = thread functionality
  c = create
  o = open
  s = suspend
  r = resume

str = string manipulation functionality
  c = compare

zc = there were no call instructions in the function

xref = number of cross references for the function

'''


import re
import collections


GHIDRA_FUNC_PREFIX = 'FUN_'
CUSTOM_AUTO_FUNC_PREFIX = 'f_p__'
CUSTOM_AUTO_THREAD_FUNC_PREFIX  = 'f_p__TS__'

OP_TYPE_PUSH_REGISTER = 512
#OP_TYPE_CALL_REGISTER_NO_REFERENCE = 516
#OP_TYPE_CALL_REGISTER_WITH_REFERENCE = 8708
OP_TYPE_CALL_STATIC_FUNCTION = 8256
OP_TYPE_CALL_DATA_VARIABLE = 8324 # with or without known reference
#OP_TYPE_CALL_STACK_VARIABLE = 4202500



def main():

    print('{:s}\n{:s}'.format('=' * 100, 'Function_Preview Script Starting'))


    
    #
    # rename thread start functions
    # do this first so to potentially create new functions 
    # because often the thread start functions don't get 
    # analyzed by default
    #

    # get initial thread starts
    threadRootsList = Get_Thread_Roots()

    # rename thread starts with auto name
    for rootEa in threadRootsList:
        newFuncName = '{:s}{:s}{:s}'.format(CUSTOM_AUTO_THREAD_FUNC_PREFIX , GHIDRA_FUNC_PREFIX, rootEa.toString())

        curFunc = getFunctionAt(rootEa)
        if curFunc == None:
            createFunction(rootEa, newFuncName)
        else:
            curFunc.setName(newFuncName, ghidra.program.model.symbol.SourceType.USER_DEFINED)


    
    #
    # get list of all functions to rename and leaf nodes.  Get leaf nodes by
    # checking if each function is a parent. leaf nodes will not be a parent functions
    # ignore library / thunk functions
    #


    # start with all unidentified functions, i.e. all functions that start with the
    # Ghidra standard function prefix or this scripts custom function prefix
    # assume any other function name was either named from a library signature or manually by
    # a user, and you don't want to overwrite those function names.  Also ignore thunk functions
    # skip thread start functions because having all of the target functionality added to the 
    # thread function name is generally overkill.
    funcList = [f for f in currentProgram.getListing().getFunctions(True) if f.getName().startswith( (GHIDRA_FUNC_PREFIX, CUSTOM_AUTO_FUNC_PREFIX) ) and not f.getName().startswith(CUSTOM_AUTO_THREAD_FUNC_PREFIX)]
    funcList = [f for f in funcList[:] if f.isThunk() == False]

    # identify all parent nodes within unidentified function set
    parentNodes = set()
    for curFunc in funcList:
        curParentNodes = curFunc.getCallingFunctions(monitor)
        parentNodes.update(curParentNodes)


    # store all functions that are not a parent as a leaf node
    leafNodes = [f for f in funcList if f not in parentNodes ]


    
    #
    # recusively apply renaming to unidentified functions starting from leaf nodes
    # up through parents.  This will ensure child functionality is propagated
    # up through the parent functions
    #
    # do recursively until no changes are made.  This will ensure that all of the
    # child function capabilities are propagated up through the parents
    #
    while True:
        funcRenamedCount = 0
        nodesTraversed = set()
        curNodes = leafNodes[:]
        while True:

            # rename each function in current level of nodes
            parentNodes = set()
            for curFunc in curNodes:

                # rename function and track if new name is actually different than old name
                # this count is used to determine when to finish recursively renaming functions
                oldFuncName = curFunc.getName()
                newFuncNameProposed = Build_New_Func_Name(curFunc)
                curFunc.setName(newFuncNameProposed, ghidra.program.model.symbol.SourceType.USER_DEFINED)
                newFuncNameActual = curFunc.getName()
                if oldFuncName != newFuncNameActual: funcRenamedCount += 1

                # add current function into nodesTraversed so you can check for infinite loops
                nodesTraversed.add(curFunc)

                # get parent nodes that are in the unidentified functions list
                # ignore any parents not in that list assuming they are library
                # calls or other functions we don't want to overwrite
                curParentNodes = curFunc.getCallingFunctions(monitor)
                parentNodes.update( curParentNodes & set(funcList) )

                # remove any functions from the nodesTraversed list to eliminate infinite loops
                parentNodes = parentNodes - nodesTraversed


            # inner whie loop exit condition
            if len(parentNodes) == 0: break

            # copy parentNodes to curNodes to rename in next iteration of loop
            curNodes = parentNodes.copy()

        # outer while loop exit condition
        if funcRenamedCount == 0: break


    print('{:s}\n{:s}'.format('Function_Preview Script Completed', '=' * 100))




def Get_Prev_Target_Instruction(curInstr, mnem, N, MAX_INSTRUCTIONS = 9999):
    '''
    gets N'th previous target instruction from the curInstr
    function will only go back MAX_INSTRUCTIONS
    function will not search outside of current function if the
    current instruction is inside a defined function
    returns None on failure
    '''


    # get address set of current function to use in determining if prev instruction
    # is outside of current function
    try:
        funcBody = getFunctionContaining(curInstr.getAddress()).getBody()
    except:
        funcBody = None


    # get Nth prev instruction
    totalInstructionCount = 0
    targetInstructionCount = 0
    while (totalInstructionCount < MAX_INSTRUCTIONS) and (targetInstructionCount < N):
        curInstr = curInstr.getPrevious()

        if curInstr == None: break
        if funcBody != None:
            if funcBody.contains(curInstr.getAddress()) == False: break

        if curInstr.getMnemonicString().lower() == mnem.lower(): targetInstructionCount += 1

        totalInstructionCount += 1


    # return the results
    if targetInstructionCount == N:
        result = curInstr
    else:
        result = None

    return result






def Get_Thread_Roots():
    '''
    returns a list of addresses of the root functions for all threads
    found in the program
    '''

    # list of  thread creation functions
    funcNamesList = ['CreateThread', '_beginthreadex', '__beginthreadex', '_beginthread', '__beginthread']

    # go through every thread create option
    threadStartEaSet = set()
    for funcName in funcNamesList:
        # set thread start argument because it is different number based on API used
        argIndex = 1 if funcName.lstrip('_') == 'beginthread' else 3

        # get list of API references
        funcList = list(currentProgram.getSymbolTable().getSymbols(funcName))
        if len(funcList) == 0: continue

        # get all references to target function
        funcReferences = funcList[0].getReferences()

        for ref in funcReferences:

            # if reference location is a call instruction
            if 'call' not in ref.getReferenceType().getName().lower(): continue

            # find the actual thread start function
            refInstr = getInstructionAt(ref.getFromAddress())
            mnemInstr = Get_Prev_Target_Instruction(refInstr, 'push', argIndex, 10)
            if mnemInstr == None: continue


            # get thread start address
            if mnemInstr.getOperandType(0) == OP_TYPE_PUSH_REGISTER:
                # if thread start was a register, look for root address where register
                # value was set
                regStr = mnemInstr.getRegister(0).getName().lower()
                for i in range(5):
                    mnemInstr = Get_Prev_Target_Instruction(mnemInstr, 'mov', 1, 10)
                    if mnemInstr == None: break

                    if mnemInstr.getRegister(0).getName().lower() == regStr:
                        rootEa = mnemInstr.getOperandReferences(1)[0].getToAddress()
                        if getFunctionContaining(rootEa) != None: threadStartEaSet.add(rootEa)

                        break
            else:
                # assume normal push offset
                rootEa = mnemInstr.getOperandReferences(0)[0].getToAddress()
                threadStartEaSet.add(rootEa)



    return threadStartEaSet



def Build_New_Func_Name(func):
    '''
    function will return a string for naming functionality based on desired
    functionality found
    functionality is split into categories.  Each category has a
    single identifier to indicate a generic capability for that category
    e.g. netwCSR = network category, connect, send, and receive capabilities
    '''

    # use ordered dictionary so that categories are always printed
    # in the same order
    categoryNomenclatureDict = collections.OrderedDict()
    categoryNomenclatureDict['netw'] = ['b','c','l','s','r','t','m']
    categoryNomenclatureDict['reg'] = ['h','r','w','d']
    categoryNomenclatureDict['file'] = ['h','r','w','d','c','m','e']
    categoryNomenclatureDict['proc'] = ['h','e','c','t','r','w']
    categoryNomenclatureDict['serv'] = ['h','c','d','s','r','w']
    categoryNomenclatureDict['thread'] = ['c','o','s','r']
    categoryNomenclatureDict['str'] = ['c']



    # for dictionary, list only the basenames, leave off prefixes of '_'
    # and any suffix such as Ex, ExA, etc.  These will be stripped from
    # the functions calleed to account for all variations
    apiPurposeDict = {
        'socket':'netwB',

        #WSAStartup':'netwC',
        'connect':'netwC',
        'InternetOpen':'netwC',
        'InternetConnect':'netwC',
        'InternetOpenURL':'netwC',
        'HttpOpenRequest':'netwC',
        'WinHttpConnect':'netwC',
        'WinHttpOpenRequest':'netwC',

        'bind':'netwL',
        'listen':'netwL',
        'accept':'netwL',

        'send':'netwS',
        'sendto':'netwS',
        'InternetWriteFile':'netwS',
        'HttpSendRequest':'netwS',
        'WSASend':'netwS',
        'WSASendTo':'netwS',
        'WinHttpSendRequest':'netwS',
        'WinHttpWriteData':'netwS',

        'recv':'netwR',
        'recvfrom':'netwR',
        'InternetReadFile':'netwR',
        'HttpReceiveHttpRequest':'netwR',
        'WSARecv':'netwR',
        'WSARecvFrom':'netwR',
        'WinHttpReceiveResponse':'netwR',
        'WinHttpReadData':'netwR',
        'URLDownloadToFile':'netwR',

        'inet_addr':'netwM',
        'htons':'netwM',
        'htonl':'netwM',
        'ntohs':'netwM',
        'ntohl':'netwM',

        # to common due to error conditions
        # basically becomes background noise
        #
        #'closesocket':'netwT',
        #'shutdown':'netwT',


        'RegOpenKey':'regH',

        'RegQueryValue':'regR',
        'RegGetValue':'regR',
        'RegEnumValue':'regR',

        'RegSetValue':'regW',
        'RegSetKeyValue':'regW',

        'RegDeleteValue':'regD',
        'RegDeleteKey':'regD',
        'RegDeleteKeyValue':'regD',

        'RegCreateKey':'regC',

        'CreateFile':'fileH',
        'fopen':'fileH',

        'fscan':'fileR',
        'fgetc':'fileR',
        'fgets':'fileR',
        'fread':'fileR',
        'ReadFile':'fileR',

        'flushfilebuffers':'fileW',
        'fprintf':'fileW',
        'fputc':'fileW',
        'fputs':'fileW',
        'fwrite':'fileW',
        'WriteFile':'fileW',

        'DeleteFile':'fileD',

        'CopyFile':'fileC',

        'MoveFile':'fileM',

        'FindFirstFile':'fileE',
        'FindNextFile':'fileE',

        'strcmp':'strC',
        'strncmp':'strC',
        'stricmp':'strC',
        'wcsicmp':'strC',
        'mbsicmp':'strC',
        'lstrcmp':'strC',
        'lstrcmpi':'strC',

        'OpenService':'servH',

        'QueryServiceStatus':'servR',
        'QueryServiceConfig':'servR',

        'ChangeServiceConfig':'servW',
        'ChangeServiceConfig2':'servW',

        'CreateService':'servC',

        'DeleteService':'servD',

        'StartService':'servS',

        'CreateToolhelp32Snapshot':'procE',
        'Process32First':'procE',
        'Process32Next':'procE',

        'OpenProcess':'procH',

        'CreateProcess':'procC',
        'CreateProcessAsUser':'procC',
        'CreateProcessWithLogon':'procC',
        'CreateProcessWithToken':'procC',
        'ShellExecute':'procC',

        # to common due to error conditions
        # basically becomes background noise
        #
        #'ExitProcess':'procT',
        #'TerminateProcess':'procT',

        'ReadProcessMemory':'procR',

        'WriteProcessMemory':'procW',

        'CreateThread':'threadC',
        'beginthread':'threadC',
        'beginthreadex':'threadC', # EXCEPTION: include ex because it's lowercase and won't be caught by case-sensitive suffix stripper routine later

        'OpenThread':'threadO',

        'SuspendThread':'threadS',

        'ResumeThread':'threadR',

    }


    # get function info
    funcOrigName = func.getName()
    funcAddressSet = func.getBody()

    # get count of number of times current function is called
    refToCount = getSymbolAt(func.getEntryPoint()).getReferenceCount()

    # get all calls in current function
    callList = []
    curInstr = getInstructionAt(func.getEntryPoint())
    while ( (curInstr != None) and (funcAddressSet.contains(curInstr.getAddress()) == True) ):
        if curInstr.getMnemonicString().lower() == 'call': callList.append(curInstr)
        curInstr = curInstr.getNext()



    # remove any recursive calls, otherwise any functionality in function
    # will also be treated as child functionality and appended to child
    # portion of name
    recursiveList = []
    for curCall in callList:
        curOpRef = curCall.getOperandReferences(0)

        # skip calls to registers or any type that doesn't store adddress information
        if len(curOpRef) == 0: continue

        # check operand reference to make sure it's not recursive
        if curOpRef[0].getToAddress().equals(func.getEntryPoint()) == True:
            recursiveList.append(curCall)
    callList = list(set(callList) - set(recursiveList))



    # if no calls, return appropriate response
    if len(callList) == 0:
        # check if functiton is a thunk
        if func.isThunk() == True:
            callList.append(getInstructionAt(func.getEntryPoint()))
        else:
            # otherwise, return zero call
            return '{:s}zc_{:s}{:s}__xref_{:02d}'.format(CUSTOM_AUTO_FUNC_PREFIX, GHIDRA_FUNC_PREFIX, func.getEntryPoint().toString(), refToCount)


    #
    # if calls are found, try to identify functionality
    #
    apiUsed = set()

    # process calls with external reference
    for curCall in callList:
        if curCall.getExternalReference(0) != None:
            # extract API basename to ignore prefix/suffix, e.g. _, Ex, ExA
            curApiName = curCall.getExternalReference(0).getLabel()
            pattern = '^(?:FID_conflict:)?(?:_)*(?P<baseName>.+?)(?:A|W|Ex|ExA|ExW)?(?:@[a-fA-F0-9]+)?$'
            match = re.search(pattern, curApiName)
            curApiName = match.group('baseName')

            # add current API name to summary set
            apiUsed.add(curApiName)


    # process calls to statically linked functions
    for curCall in callList:
        if curCall.getOperandType(0) == OP_TYPE_CALL_STATIC_FUNCTION:
            curApiName = getFunctionAt(curCall.getReferencesFrom()[0].getToAddress()).getName()
            if curApiName.startswith((GHIDRA_FUNC_PREFIX, CUSTOM_AUTO_FUNC_PREFIX, CUSTOM_AUTO_THREAD_FUNC_PREFIX )) == False:
                # extract API basename to ingnore prefix/suffix, e.g. _, Ex, ExA
                pattern = '^(?:FID_conflict:)?(?:_)*(?P<baseName>.+?)(?:A|W|Ex|ExA|ExW)?(?:@[a-fA-F0-9]+)?$'
                match = re.search(pattern, curApiName)
                curApiName = match.group('baseName')

                # add current API name to summary set
                apiUsed.add(curApiName)


    # process calls to function pointers stored in data variables
    for curCall in callList:
        if curCall.getOperandType(0) == OP_TYPE_CALL_DATA_VARIABLE:
            curOpEa = curCall.getReferencesFrom()[0].getToAddress()
            curData = getDataAt(curOpEa)

            # getDataAt should return data object for defined and undefined data,
            # but there seems to be a bug and sometimes returns None on undefined data
            if curData == None: curData = getUndefinedDataAt(curOpEa)

            # get the data variable label
            if curData.getExternalReference(0) != None:
                curApiName = curData.getExternalReference(0).getLabel()
            else:
                curApiName = curData.getLabel()


            if curApiName.lower().startswith(('dat_', 'byte_', 'word_', 'dword_', 'qword_')) == False:
                # extract API basename to ingnore prefix/suffix, e.g. _, Ex, ExA
                pattern = '^(?:FID_conflict:)?(?:_)*(?P<baseName>.+?)(?:A|W|Ex|ExA|ExW)?(?:@[a-fA-F0-9]+)?$'
                match = re.search(pattern, curApiName)
                curApiName = match.group('baseName')

                # add current API name to summary set
                apiUsed.add(curApiName)




    # map API's called to functionality to use for naming
    implementedApiPurpose = set()
    for entry in apiUsed:
        implementedApiPurpose.add(apiPurposeDict.get(entry))


    # identify functionality from child functions already renamed by this script
    # this will allow api usage to propagate up to the root function
    childFunctionImplementedApiPurpose = dict()
    for curCall in callList:
        if curCall.getOperandType(0) == OP_TYPE_CALL_STATIC_FUNCTION:
            curApiName = getFunctionAt(curCall.getReferencesFrom()[0].getToAddress()).getName()
            if curApiName.startswith(CUSTOM_AUTO_FUNC_PREFIX) == True:

                # pull out api capabilities based on naming convention
                for category in categoryNomenclatureDict:
                    pattern = category + '_' + '([a-zA-Z]+)+_?([a-zA-Z]+)?'
                    match = re.search(pattern, curApiName)

                    # if category is found, save into results
                    if match is not None:
                        apiPurpose = set()
                        if match.group(1) is not None: apiPurpose.update(list(match.group(1).lower()))
                        if match.group(2) is not None: apiPurpose.update(list(match.group(2).lower()))
                        if category in childFunctionImplementedApiPurpose:
                            childFunctionImplementedApiPurpose[category].update(apiPurpose)
                        else:
                            childFunctionImplementedApiPurpose[category] = apiPurpose



    #
    # create function name based on API functionality found
    #

    newFuncNamePurpose = ''

    # for each category, loop through all the nomenclature symbols
    # if the symbol is found in the current function, add it to the parent string
    # if the symbol is found in a child function, add it to child string
    for category in categoryNomenclatureDict:

        # build the symbol list for the parent function
        parentStr = ''
        for symbol in categoryNomenclatureDict[category]:
            if (category + symbol.upper()) in implementedApiPurpose:
                parentStr += symbol.upper()


        # build the symbol list for the child functions
        childStr = ''
        if category in childFunctionImplementedApiPurpose:
            for symbol in categoryNomenclatureDict[category]:
                if symbol.lower() in childFunctionImplementedApiPurpose[category]:
                    childStr += symbol.lower()

        # combine the parent / child symbol list into one final string
        if (len(parentStr) > 0) or (len(childStr) > 0):
            newFuncNamePurpose = newFuncNamePurpose + category
            if len(parentStr) > 0: newFuncNamePurpose = newFuncNamePurpose + '_' + parentStr
            if len(childStr) > 0: newFuncNamePurpose = newFuncNamePurpose + '_' + childStr
            newFuncNamePurpose = newFuncNamePurpose + '__'






    # build the final function name
    if len(newFuncNamePurpose) > 0:
        # targeted functionality found
        finalFuncName = '{:s}{:s}xref_{:02d}_{:s}'.format(CUSTOM_AUTO_FUNC_PREFIX, newFuncNamePurpose, refToCount, func.getEntryPoint().toString())
    else:
        # no targeted functionality identified
        finalFuncName = '{:s}{:s}{:s}__xref_{:02d}'.format(CUSTOM_AUTO_FUNC_PREFIX, GHIDRA_FUNC_PREFIX, func.getEntryPoint().toString(), refToCount)

    return finalFuncName

if __name__ == '__main__':
    main()


 
5. FIND CRYPT
// Quickly find references to cryptographic functions and constants.
// This is a port of IDA Pro's FindCrypt plugin, with an updated and customizable signature database.
//@category Analysis

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.zip.GZIPInputStream;

import docking.widgets.dialogs.MultiLineMessageDialog;
import ghidra.app.script.GhidraScript;
import ghidra.app.services.ConsoleService;
import ghidra.app.tablechooser.*;
import ghidra.app.util.datatype.DataTypeSelectionDialog;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.address.*;
import ghidra.program.model.data.ArrayDataType;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.Undefined;
import ghidra.program.model.data.Undefined4DataType;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.DataIterator;
import ghidra.program.model.listing.Function;
import ghidra.util.Msg;
import ghidra.util.data.DataTypeParser.AllowedDataTypes;
import ghidra.util.task.CancelOnlyWrappingTaskMonitor;

public class FindCrypt extends GhidraScript {
	private static final int CRYPT_COUNTER = 20;
	private static final double DETECT_THRESHOLD = 0.8;
	private static final int SKIP_SMALLER_SUB_CONSTANTS = 4;

	public static class InternalParams {
		// Disable automatic database update.
		public static final boolean __FORCE_NO_DBUPDATE = false;
		// Disable automatic script version check.
		public static final boolean __FORCE_NO_SCRIPTUPDATE = false;

		// Current script version, used for enforcing; modifications not recommended unless you know what you're doing.
		public static final String __SCRIPT_VERSION = "7";
	}

	public static class GuiHandler {
		public static void ShowMessage(String _title, String _message, String _details, int _icon) {
			MultiLineMessageDialog.showMessageDialog(null, _title, _message, _details, _icon);
		}
	}

	public static class UpdateManager {
		private String _BASE = "";
		private String _LOCAL = "";

		public String GetChangelog() {
			URL url;
			try {
				url = new URL(this._BASE + "/last_chlog.txt");
				URLConnection urlConnection = url.openConnection();
				InputStream in = new BufferedInputStream(urlConnection.getInputStream());

				var _lastchLog = new String(in.readAllBytes(), "UTF-8");

				return _lastchLog;
			} catch (Exception e) {
				return "Error recovering last changelog:\n" + e.getMessage();
			}
		}

		public boolean CheckScriptVersion() {
			URL url;
			try {
				url = new URL(this._BASE + "/script_update.txt");
				URLConnection urlConnection = url.openConnection();
				InputStream in = new BufferedInputStream(urlConnection.getInputStream());

				var _last = Integer.parseInt(new String(in.readAllBytes(), "UTF-8"));
				var _local = Integer.parseInt(InternalParams.__SCRIPT_VERSION);

				if (_last > _local) {
					MultiLineMessageDialog.showMessageDialog(null, "FindCrypt Ghidra",
							"A new version of FindCrypt-Ghidra is available:", this.GetChangelog() + "\n\n\thttps://github.com/d3v1l401/FindCrypt-Ghidra", 1);
				}

				return true;
			} catch (Exception e) {
				// Don't bother, internet may not be available.
			}
			return false;
		}

		public boolean CheckDatabaseVersion() {
			URL url;
			try {
				url = new URL(this._BASE + "/last_update.txt");
				URLConnection urlConnection = url.openConnection();
				InputStream in = new BufferedInputStream(urlConnection.getInputStream());

				var _last = Integer.parseInt(new String(in.readAllBytes(), "UTF-8"));
				var _local = Integer.parseInt(Files.readString(Paths.get(this._LOCAL + "last_update.txt")));

				if (_last > _local) {
					System.out.println("A new version of the database is being downloaded (" + _local + " -> " + _last + ").");

					url = new URL(this._BASE + "/database.d3v");
					ReadableByteChannel readableByteChannel = Channels.newChannel(url.openStream());

					new File(this._LOCAL + "database.d3v").delete();
					FileOutputStream fileOutputStream = new FileOutputStream(this._LOCAL + "database.d3v");
					fileOutputStream.getChannel().transferFrom(readableByteChannel, 0, Long.MAX_VALUE);
					fileOutputStream.close();

					new File(this._LOCAL + "last_update.txt").delete();
					var _handle = new FileWriter(this._LOCAL + "last_update.txt");
					_handle.write(String.valueOf(_last));
					_handle.close();
				}

				return true;
			} catch (Exception e) {
				// Don't bother, internet may not be available.
			}
			return false;
		}

		public UpdateManager(String _baseUrl, String _basePath) {
			this._BASE = _baseUrl;
			this._LOCAL = _basePath;
		}
	}

	public static class DatabaseManager {
		// Structure of database file, for reference.
		/*******************************************************************
		 | MAGIC (4)    | Total Entries (2)           	                   |
		 | NameSize (4) | Name (x) | isCompressed(1) | ESize(4) | BSize(4) |
		 | Buffer (x)   | ...                                              |
		 ******************************************************************/

		// Structure of the database entry.
		public class EntryInfo {
			private byte[] _buffer;
			private String _name;
			private int _elementSize;

			public EntryInfo(byte[] _buff, int _elementSize, String _name) {
				this._buffer = _buff;
				this._elementSize = _elementSize;
				this._name = _name;
			}
		}

		private boolean             _loaded         = false;
		private static final int    _EXPECTED_MAGIC = 0xD3010401;
		private short               _totalEntries   = 0;

		private ArrayList<EntryInfo> _consts = new ArrayList<>();

		public int DbSize() {
			return this._totalEntries;
		}

		public DatabaseManager(String _path) {
			if (!this._loaded) {
				try (DataInputStream _stream = new DataInputStream(new FileInputStream(_path))) {
					var _curMagic = _stream.readInt();

					if (_curMagic != _EXPECTED_MAGIC)
						throw new Exception("Specified database file has a different magic from the expected one.");

					this._totalEntries = _stream.readShort();
					if (this._totalEntries == 0) {
						GuiHandler.ShowMessage("FindCrypt - Warning", "Something unusual happened while loading the database.",
								"The database contains no entries, while this is not error, the script will not scan anything", 2);
						return; // No need to proceed at all.
					}

					for (var i = 0; i < this._totalEntries; i++) {
						var _nameSize = _stream.readInt();
						if (_nameSize == 0)
							throw new Exception("An entry has 0 length name.");
						var _name = new byte[_nameSize];
						_stream.read(_name);

						var _isCompressed = _stream.readByte();
						var _elementSize = _stream.readInt();
						var _buffSize = _stream.readInt();
						if (_buffSize == 0)
							throw new Exception("An entry has no buffer (" + _name + ")");
						var _buff = new byte[_buffSize];
						_stream.read(_buff);

						if (_isCompressed == 0x01) {
							// https://stackoverflow.com/questions/12531579/uncompress-a-gzip-string-in-java
							ByteArrayInputStream bytein = new ByteArrayInputStream(_buff);
							GZIPInputStream gzin = new GZIPInputStream(bytein);
							ByteArrayOutputStream byteout = new ByteArrayOutputStream();

							int res = 0;
							byte buf[] = new byte[1024];
							while (res >= 0) {
								res = gzin.read(buf, 0, buf.length);
								if (res > 0) {
									byteout.write(buf, 0, res);
								}
							}
							byte uncompressed[] = byteout.toByteArray();

							this._consts.add(new EntryInfo(uncompressed, _elementSize, new String(_name, "UTF-8")));
						} else
							this._consts.add(new EntryInfo(_buff, _elementSize, new String(_name, "UTF-8")));
					}

					_stream.close();
					this._loaded = true;

				} catch (Exception e) {
					GuiHandler.ShowMessage("FindCrypt - Error" , "An error happened while loading the database.", e.getMessage(), 0);
				}
			}
		}
	}

	public static class WorksetManager {
		private static final String __FCUPD_BASEURL = "https://raw.githubusercontent.com/d3v1l401/FindCrypt-Ghidra/master/findcrypt_ghidra";

		private static final String __FCDATA_DIR = System.getProperty("user.home") + File.separator + "findcrypt_ghidra" + File.separator;

		private static DatabaseManager _dbHandler;
		private static UpdateManager   _updHandler;

		public static boolean Initialize() {
			_dbHandler = new DatabaseManager(__FCDATA_DIR + "database.d3v");
			_updHandler = new UpdateManager(__FCUPD_BASEURL, __FCDATA_DIR);

			if (_dbHandler != null && _updHandler != null) {
				_updHandler.CheckDatabaseVersion();
				_updHandler.CheckScriptVersion();
				return true;
			}

			return false;
		}

		public static int GetDatabaseSize() {
			return _dbHandler.DbSize();
		}

		public static ArrayList<DatabaseManager.EntryInfo> GetDB() {
			return _dbHandler._consts;
		}
	}

	public class FoundCryptoEntry {
		private DatabaseManager.EntryInfo _dbentry;
		private AddressSet _addresses;
		private Function _function;
		private double _detectionRate;

		public FoundCryptoEntry(DatabaseManager.EntryInfo _dbentry, AddressSet _addresses, Double _detectionRate) {
			this._dbentry = _dbentry;
			this._addresses = _addresses;
			this._function = getFunctionContaining(_addresses.getMinAddress());
			this._detectionRate = _detectionRate;
		}

		public String toString() {
			if (_function != null)
				return String.format("%s (%s) -> %s\n", _function.getName(), _dbentry._name, _addresses.getMinAddress().toString());

			return String.format("%s -> %s\n", _dbentry._name, _addresses.getMinAddress().toString());
		}

		public Boolean isFullMatch() {
			return _detectionRate == 1.0;
		}
	}

	public class FoundCryptoEntries extends ArrayList<FoundCryptoEntry> {
	}

	private TableChooserExecutor createTableExecutor() {
		TableChooserExecutor executor = new TableChooserExecutor() {

			@Override
			public String getButtonName() {
				return "Create Data";
			}

			@Override
			public boolean execute(AddressableRowObject rowObject) {
				ResultRow row = (ResultRow)rowObject;

				boolean commit = true;
				var transaction = currentProgram.startTransaction(getScriptName() + ": Create data");
				if(row.entry.isFullMatch()) {
					try {
						createDataInRange(row.entry._addresses.getFirstRange(), row.entry._dbentry);
					}
					catch (Exception e) {
						println("Creating Data Failed: " + e.getClass().getSimpleName() + ": " + e.getMessage());
						ConsoleService console = state.getTool().getService(ConsoleService.class);
						e.printStackTrace(console.getStdOut());
						commit = false;
					}
				}
				currentProgram.endTransaction(transaction, commit);
				return true;
			}

			private Data createDataInRange(AddressRange range, DatabaseManager.EntryInfo alg) throws Exception {
				ArrayList<Data> dataToDestroy = new ArrayList<>();
				Data data = getDataContaining(range.getMinAddress());
				if(data != null && data.isDefined() && !Undefined.class.isAssignableFrom(data.getDataType().getClass()))
					throw new Exception("New data overlaps with defined data");
				else if(data != null && data.getMinAddress() != range.getMinAddress())
					dataToDestroy.add(data);

				DataIterator di = currentProgram.getListing().getData(new AddressSet(range), true);
				while(di.hasNext()) {
					data = di.next();
					if(data.isDefined() && !Undefined.class.isAssignableFrom(data.getDataType().getClass()))
						throw new Exception("New data overlaps with defined data");

					dataToDestroy.add(data);
				}

				for (Data d : dataToDestroy)
					removeData(d);

				PluginTool tool = state.getTool();
				DataType suggesteDataType = Undefined4DataType.dataType;
				var dialog = new DataTypeSelectionDialog(tool, currentProgram.getDataTypeManager(),
						alg._elementSize, AllowedDataTypes.FIXED_LENGTH);

				dialog.setInitialDataType(suggesteDataType);
				dialog.setTitle("Choose datatype for elements of: " + alg._elementSize);
				tool.showDialog(dialog);

				DataType chosenType = dialog.getUserChosenDataType();
				if (chosenType.getLength() % alg._elementSize != 0)
					throw new Exception("Selected datatype doesn't have suitable length");

				ArrayDataType adt = new ArrayDataType(chosenType, (int) (range.getLength() / chosenType.getLength()), chosenType.getLength());
				return createData(range.getMinAddress(), adt);
			}
		};

		return executor;
	}

	private class ResultRow implements AddressableRowObject {
		private FoundCryptoEntry entry;

		public ResultRow(FoundCryptoEntry entry) {
			this.entry = entry;
		}

		@Override
		public Address getAddress() {
			return entry._addresses.getMinAddress();
		}
	}

	private void configureTableColumns(TableChooserDialog dialog) {
		dialog.addCustomColumn(new StringColumnDisplay() {
			@Override
			public String getColumnValue(AddressableRowObject rowObject) {
				return ((ResultRow)rowObject).entry._dbentry._name;
			}

			@Override
			public String getColumnName() {
				return "Name";
			}
		});

		dialog.addCustomColumn(new AbstractComparableColumnDisplay<Double>() {
			@Override
			public Double getColumnValue(AddressableRowObject rowObject) {
				return ((ResultRow)rowObject).entry._detectionRate;
			}

			@Override
			public String getColumnName() {
				return "Detection Rate";
			}
		});
	}

	@Override
	protected void run() throws Exception {
		println("FindCrypt - Ghidra Edition by d3vil401 (https://d3vsite.org)\n" +
					"Special thanks to Pawlos for fragmented constant scans\n" +
					"Original idea by Ilfak Guilfanov (http://hexblog.com)" +
					"\n");

		Boolean headless = isRunningHeadless();

		if (currentProgram == null) {
			Msg.info(this, "No program loaded, aborting.");
			return;
		}

		var startTime = System.currentTimeMillis();
		WorksetManager.Initialize();

		println("Loaded " + WorksetManager.GetDatabaseSize() + " signatures.");
		monitor.initialize(WorksetManager.GetDatabaseSize());
		monitor.setProgress(0);

		var cancelMonitor = new CancelOnlyWrappingTaskMonitor(monitor);
		var memory = currentProgram.getMemory();
		var searchStart = memory.getMinAddress();
		var searchEnd = memory.getMaxAddress();

		if (currentSelection != null && memory.contains(currentSelection)) {
			searchStart = currentSelection.getMinAddress();
			searchEnd = currentSelection.getMaxAddress();
		}

		var foundEntries = new FoundCryptoEntries();
		for (var alg: WorksetManager.GetDB()) {
			monitor.checkCanceled();
			monitor.setMessage("Looking for " + alg._name);

			var addressSet = new AddressSet();
			var detectionRate = 0.0;

			var _found = memory.findBytes(searchStart, searchEnd, alg._buffer, null, true, cancelMonitor);
			if (_found != null) {
				addressSet.add(_found, _found.add(alg._buffer.length));
				detectionRate = 1.0;
			} else {
				if (alg._elementSize < SKIP_SMALLER_SUB_CONSTANTS)
					continue; //skip too small constants - too many false positives

				var size = alg._buffer.length;
				var totalSubItems = size / alg._elementSize;
				var subItemsToCheck = Math.min(totalSubItems, CRYPT_COUNTER);

				for(var i = 0; i < subItemsToCheck; i++) {
					var offset = i * alg._elementSize;
					var _foundPart = memory.findBytes(searchStart, searchEnd,
						Arrays.copyOfRange(alg._buffer, offset, offset + alg._elementSize),
						null, true, cancelMonitor);

					if (_foundPart != null)
						addressSet.add(_foundPart, _foundPart.add(alg._elementSize));
				}
				detectionRate = (double)addressSet.getNumAddressRanges() / totalSubItems;
			}

			if(!addressSet.isEmpty() && detectionRate >= DETECT_THRESHOLD)
				foundEntries.add(new FoundCryptoEntry(alg, addressSet, detectionRate));

			monitor.incrementProgress(1);
		}

		var _formatted = "";
		for(var entry : foundEntries) {
			_formatted += entry.toString() + System.lineSeparator();
			createBookmark(entry._addresses.getMinAddress(), "FindCrypt",
				String.format("%s dr=%.2f", entry._dbentry._name, entry._detectionRate));
		}

		// Only show results if something has been found.
		if (foundEntries.size() >= 1) {
			String messageString = String.format("A total of %d signatures have been found in %dms.",
				foundEntries.size(), System.currentTimeMillis() - startTime);
			if (headless)
				println(messageString + System.lineSeparator() + _formatted);
			else {
				println(messageString);
				var dialog = createTableChooserDialog("FindCrypt", createTableExecutor());
				configureTableColumns(dialog);
				for (var e : foundEntries)
					dialog.add(new ResultRow(e));

				dialog.show();
			}
		}
	}
}

